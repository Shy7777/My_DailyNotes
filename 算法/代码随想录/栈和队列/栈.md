# 力扣20与1047
---

### **Python 栈问题通用模板**
```python
class Solution:
    def solve(self, input_data) -> ReturnType:
        stack = []  # 1. 初始化栈
        
        for item in input_data:  # 2. 遍历输入
            if not stack:  # 3. 栈空时直接入栈
                stack.append(item)
            elif meets_condition(stack[-1], item):  # 4. 定义匹配条件
                stack.pop()  # 5. 匹配则消除（弹出栈顶）
            else:
                stack.append(item)  # 6. 不匹配则入栈
        
        return ''.join(stack)  # 7. 栈转结果（字符串/列表等）
```

---

### **关键组件说明**
| 步骤 | 作用 | 你的题目示例 |
|------|------|--------------|
| **1. 初始化栈** | 用 `list` 模拟栈 | `stack = []` |
| **2. 遍历输入** | 逐个处理元素 | `for char in s:` |
| **3. 栈空处理** | 避免越界访问 | `if not stack:` |
| **4. 匹配条件** | **核心逻辑** | 括号匹配 / 相邻重复 |
| **5. 消除操作** | 弹出栈顶 | `stack.pop()` |
| **6. 入栈操作** | 保留未匹配元素 | `stack.append(item)` |
| **7. 结果转换** | 栈 → 目标类型 | `''.join(stack)` |

---

### **两题的条件差异**
| 题目 | `meets_condition` 实现 |
|------|------------------------|
| **Valid Parentheses** | `mapping[char] == stack[-1]`（右括号匹配左括号） |
| **Remove Duplicates** | `stack[-1] == item`（相邻字符相同） |

---

### **使用技巧**
1. **栈空检查**：始终先判断 `if not stack` 避免 `stack[-1]` 越界
2. **结果转换**：
   - 字符串：`''.join(stack)`
   - 列表：直接返回 `stack`
3. **条件设计**：明确「什么情况下需要消除元素」
