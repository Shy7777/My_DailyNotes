# 力扣239
---

### **Python 双端队列问题通用模板**
```python
from collections import deque

class Solution:
    def solve(self, input_data, window_size) -> ReturnType:
        q = deque()  # 1. 初始化双端队列（通常存索引）
        res = []
        
        for i in range(len(input_data)):  # 2. 遍历输入
            # 3. 移除过期元素（窗口左边界外的元素）
            if q and q[0] <= i - window_size:
                q.popleft()
            
            # 4. 维护队列单调性（从右侧弹出不符合条件的元素）
            while q and meets_condition(input_data[q[-1]], input_data[i]):
                q.pop()
            
            # 5. 当前元素入队
            q.append(i)
            
            # 6. 记录结果（窗口形成后）
            if i >= window_size - 1:
                res.append(input_data[q[0]])
        
        return res
```

---

### **关键组件说明**
| 步骤 | 作用 | 你的题目示例 |
|------|------|--------------|
| **1. 初始化队列** | `deque()` 存储索引（非值） | `q = deque()` |
| **2. 遍历输入** | 逐个处理元素 | `for i in range(len(nums)):` |
| **3. 过期检查** | 移除窗口外的旧索引 | `q[0] <= i - k` |
| **4. 单调性维护** | **核心逻辑** | 弹出队尾 ≤ 当前值的索引 |
| **5. 入队操作** | 保留有效候选索引 | `q.append(i)` |
| **6. 结果记录** | 窗口形成后取队首 | `i >= k-1` 时记录 |

---

### **单调性条件差异**
| 问题类型 | `meets_condition` 实现 | 队列性质 |
|----------|------------------------|----------|
| **滑动窗口最大值** | `nums[q[-1]] <= nums[i]` | **单调递减** |
| **滑动窗口最小值** | `nums[q[-1]] >= nums[i]` | **单调递增** |

---

### **使用技巧**
1. **存储索引**：便于判断元素是否在窗口内
2. **双端操作**：
   - **左侧**：移除过期元素（`popleft()`）
   - **右侧**：维护单调性（`pop()`）
3. **时间复杂度**：O(n)（每个元素最多入队/出队一次）

这个模板适用于所有 **需要维护滑动窗口极值** 的问题（如最大值、最小值、特定条件的最值等）。遇到新题时，只需调整 **单调性条件** 和 **窗口大小逻辑** 即可！