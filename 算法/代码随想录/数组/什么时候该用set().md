### **核心摘要**  
**当需要快速判断“某个元素是否存在于一组数据中”时，就该用 `set()`** —— 它能将查找时间从 O(n) 降到 O(1)。

---

### **详细解析**  
#### 1. **典型场景**  
- **成员检测**（Membership Test）  
  如你的题目：判断链表节点值 `val` 是否在 `nums` 数组中。  
  ```python
  # 低效：每次遍历整个列表（O(n)）
  if val in nums:  # nums 是 list
  
  # 高效：哈希表直接定位（O(1)）
  if val in nums_set:  # nums_set 是 set
  ```

- **去重**  
  ```python
  unique_nums = list(set(nums))  # 移除重复元素
  ```

- **集合运算**  
  求交集、并集、差集（如 `set1 & set2`）。

#### 2. **为什么你的题目必须用 `set`？**  
- **输入规模**：`nums` 长度可达 `10^5`，链表长度也可达 `10^5`。  
- **暴力解法的代价**：  
  若用 `list`，最坏情况需 `10^5 * 10^5 = 10^10` 次操作（超时）。  
- **`set` 的优势**：  
  构建 `set` 花费 O(n)，后续每次查找 O(1)，总复杂度 O(n + m)（n=nums长度, m=链表长度）。

#### 3. **现实类比**  
- **`list` 查找**：像在无序书架上找一本书，必须一本本翻（O(n)）。  
- **`set` 查找**：像用图书索引系统，直接定位书架编号（O(1)）。

---

### **前置知识**  
**哈希表（Hash Table）**：  
- `set` 底层基于哈希表实现，通过哈希函数将元素映射到唯一存储位置。  
- **关键特性**：插入、删除、查找的平均时间复杂度均为 O(1)。

---

### **常见误区与澄清**  
1. **误区**：`set` 能完全替代 `list`  
   → **正解**：`set` 无序且不能存储重复元素，若需保持顺序或允许重复，仍需用 `list`。  

2. **误区**：小数据量时 `set` 一定更快  
   → **正解**：当 `n < 10` 时，`list` 的常数开销可能更低，但 LeetCode 数据规模通常较大，优先用 `set`。  

3. **误区**：`set` 可以存储任意类型  
   → **正解**：`set` 元素必须是**可哈希类型**（如 `int`, `str`, `tuple`），不可哈希类型（如 `list`, `dict`）会报错。

---

### **LeetCode 高频使用场景**  
| 题目类型                | 例子                          |
|-------------------------|-------------------------------|
| 查找重复/唯一元素       | 两数之和、存在重复元素        |
| 图/树的访问标记         | 岛屿数量、克隆图              |
| 字符串/数组子结构检测   | 最长无重复字符子串            |
| **你的题目类型**        | **删除链表中指定值节点**      |

> 💡 **黄金法则**：只要看到 **“是否存在”**、**“去重”**、**“快速查找”**，立刻考虑 `set`！