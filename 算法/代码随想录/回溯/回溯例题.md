	回溯思想可以想象一个n树结构，然后要构造出他的一个全解，并必要时使用剪枝
	
## 算法模板：
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 问题分类
分为子集、组合和分割问题，其中组合和分割都是找树的叶子节点，而子集是找树的所有节点
### 子集问题
78.子集问题
- 组合问题：
    - [77.组合(opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)
    - [回溯算法：组合问题再剪剪枝(opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html)
    - [216.组合总和III(opens new window)](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)
    - [17.电话号码的字母组合(opens new window)](https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html)
    - [39.组合总和(opens new window)](https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)
    - [40.组合总和II(opens new window)](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)
- 分割问题：
    - [131.分割回文串(opens new window)](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)
    - [93.复原IP地址](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)


# 深拷贝path[:]

`path[:]` 是 Python 中的**列表切片操作**，作用是**创建当前 `path` 列表的一个完整浅拷贝（shallow copy）**。在回溯算法中，这是**避免引用共享导致结果被意外修改的关键操作**。

---

### 🧠 为什么需要 `path[:]`？

在你的代码中：

```python
result.append(path[:])  # 正确：保存当前组合的副本
# vs
result.append(path)     # 错误：保存 path 的引用
```

应用代码

#### ❌ 如果直接用 `path`：

- `result` 中存储的是 `path` 的**引用（内存地址）**
- 后续 `path.pop()` 或 `path.append()` 会**同步修改 `result` 中已保存的组合**
- 最终 `result` 中所有组合都会变成空列表 `[]`（因为回溯结束时 `path` 被清空）

#### ✅ 用 `path[:]`：

- 每次保存的是 `path` **当前状态的独立副本**
- 后续对 `path` 的修改**不会影响已保存的组合**

---

### 📊 示例演示：

假设当前 `path = [1, 2]`，执行以下操作：

```python
result = []
result.append(path)    # 保存引用
path.pop()             # path 变为 [1]
print(result)          # 输出 [[1]] （错误！原本应保存 [1,2]）
```

应用代码

而用 `path[:]`：

```python
result = []
result.append(path[:]) # 保存副本
path.pop()             # path 变为 [1]，但 result 不受影响
print(result)          # 输出 [[1, 2]] （正确！）
```

应用代码

---

### 🔍 其他等效写法：

|写法|说明|
|---|---|
|`path.copy()`|Python 3.3+ 推荐的显式拷贝方法|
|`list(path)`|通过构造函数创建新列表|
|`path[:]`|传统切片拷贝（兼容性最好）|

---

### 💡 关键总结：

- **回溯算法中，保存路径时必须用拷贝**
- `path[:]` 是最简洁且广泛兼容的写法
- 忽略这一点会导致「结果全为空」或「结果重复」等隐蔽错误

你的代码中 `path[:]` 的使用完全正确，这是回溯模板的标准实践！