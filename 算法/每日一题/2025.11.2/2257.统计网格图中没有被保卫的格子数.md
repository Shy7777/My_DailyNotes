# 力扣：2257
### **核心摘要**  
这道题的核心思路是：**模拟每个警卫的视线范围，标记所有被保卫的格子，最后统计未被标记的空格子数量**。

---

### **详细解析**  

#### 1. **题目目标**
- 给定一个 `m x n` 网格，其中有 **警卫（guards）** 和 **墙（walls）**。
- 警卫能向 **上下左右四个方向** 看到所有格子，**直到遇到墙或另一个警卫为止**。
- 要求统计 **既不是警卫、也不是墙、也没有被任何警卫看到** 的格子数量。

#### 2. **关键观察**
- **视线会被阻挡**：墙和警卫都会阻挡视线（即视线不能穿过它们）。
- **只需标记被保卫的格子**：不需要知道是哪个警卫保卫的，只要被至少一个警卫看到就算。

#### 3. **算法步骤**
1. **初始化网格状态**：
   - 创建一个 `m x n` 的网格 `grid`，初始值为 `0`（表示未被保卫）。
   - 将所有 **墙** 的位置标记为 `'W'`。
   - 将所有 **警卫** 的位置标记为 `'G'`。

2. **模拟每个警卫的视线**：
   - 对每个警卫，向 **四个方向（上、下、左、右）** 逐格检查：
     - 如果遇到 `'W'` 或 `'G'`，停止该方向的视线。
     - 否则，将当前格子标记为 `1`（表示被保卫）。

3. **统计结果**：
   - 遍历整个网格，统计所有 **既不是 `'W'`、也不是 `'G'`、也不是 `1`** 的格子数量。

#### 4. **示例演示（示例1）**
- 输入：`m = 4, n = 6`, `guards = [[0,0],[1,1],[2,3]]`, `walls = [[0,1],[2,2],[1,4]]`
- 警卫 `[0,0]` 向右看，遇到墙 `[0,1]`，所以只能保卫 `[0,0]` 自身。
- 警卫 `[1,1]` 向四个方向看，能保卫部分格子，但被墙阻挡。
- 最终有 **7 个格子** 未被保卫。

---

### **前置知识**  
**模拟（Simulation）**：  
- 直接按照题目规则，逐步模拟每个警卫的视线过程。
- 时间复杂度取决于 **警卫数量 × 视线长度**，但题目限制 `m * n <= 10^5`，所以可行。

**方向数组**：  
- 用 `directions = [(0,1), (1,0), (0,-1), (-1,0)]` 表示四个方向（右、下、左、上）。

---

### **常见误区与澄清**  
1. **误区**：认为警卫的视线可以穿过其他警卫  
   → **正解**：警卫和墙一样会阻挡视线，遇到即停止。

2. **误区**：直接用 `set` 存储被保卫的格子，但忽略视线阻挡逻辑  
   → **正解**：必须逐格检查，遇到阻挡就停止，不能直接标记整行/整列。

3. **误区**：忘记警卫自身占据的格子不算“未被保卫”  
   → **正解**：警卫和墙的格子都不计入最终结果。

---

### **代码框架（Python）**
```python
def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
    # 初始化网格
    grid = [[0] * n for _ in range(m)]
    
    # 标记墙和警卫
    for r, c in walls:
        grid[r][c] = 'W'
    for r, c in guards:
        grid[r][c] = 'G'
    
    # 四个方向
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    
    # 模拟每个警卫的视线
    for r, c in guards:
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            while 0 <= nr < m and 0 <= nc < n:
                if grid[nr][nc] == 'W' or grid[nr][nc] == 'G':
                    break  # 遇到阻挡，停止
                if grid[nr][nc] == 0:
                    grid[nr][nc] = 1  # 标记为被保卫
                nr += dr
                nc += dc
    
    # 统计未被保卫的格子
    count = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 0:
                count += 1
    return count
```

---

### **优化提示**  
- **空间优化**：可以用不同整数代替 `'W'`/`'G'`（如 `2` 表示墙，`3` 表示警卫），避免字符串操作。
- **提前终止**：如果某个方向已经超出网格，直接跳过。

